Index: app/src/main/java/com/example/bettinalogistics/ui/activity/gg_map/GoogleMapViewmodel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.bettinalogistics.ui.activity.gg_map\r\n\r\nimport android.content.ContentValues\r\nimport android.util.Log\r\nimport androidx.lifecycle.MutableLiveData\r\nimport androidx.lifecycle.viewModelScope\r\nimport com.example.baseapp.BaseViewModel\r\nimport com.example.bettinalogistics.data.GoogleMapRepo\r\nimport com.example.bettinalogistics.model.AddressData\r\nimport com.google.android.gms.maps.model.LatLng\r\nimport com.google.maps.android.SphericalUtil\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.launch\r\nimport java.io.UnsupportedEncodingException\r\n\r\nclass GoogleMapViewmodel(val googleMapRepo: GoogleMapRepo) : BaseViewModel() {\r\n    var latLonOriginAddress: LatLng? = null\r\n    var latLonDestinationAddress: LatLng? = null\r\n    var distance: String? = null\r\n    var addressData: AddressData? = null\r\n    var calculateDistanceLiveData = MutableLiveData<String?>()\r\n    fun calculateDistance(orderAddress: AddressData) = viewModelScope.launch(Dispatchers.IO) {\r\n        googleMapRepo.calculateDistance(orderAddress) {\r\n           if(!it.isNullOrEmpty()){\r\n               calculateDistanceLiveData.postValue(it)\r\n           }\r\n            else{\r\n               calculateDistanceLiveData.postValue(sendRequest())\r\n           }\r\n        }\r\n    }\r\n\r\n    private fun sendRequest() : String?{\r\n        try {\r\n            val latLonOrigin = latLonOriginAddress?.latitude?.let {\r\n                latLonOriginAddress?.longitude?.let { it1 ->\r\n                    LatLng(\r\n                        it,\r\n                        it1\r\n                    )\r\n                }\r\n            }\r\n            val latLonDestination = latLonDestinationAddress?.let {\r\n                latLonDestinationAddress?.longitude?.let { it1 ->\r\n                    LatLng(\r\n                        it.latitude,\r\n                        it1\r\n                    )\r\n                }\r\n            }\r\n            val distance = SphericalUtil.computeDistanceBetween(latLonOrigin, latLonDestination);\r\n            Log.d(ContentValues.TAG, \"sendRequest: ${distance / 1000} km\")\r\n            return (distance/1000).toString()\r\n        } catch (e: UnsupportedEncodingException) {\r\n            e.printStackTrace()\r\n        }\r\n        return null\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/bettinalogistics/ui/activity/gg_map/GoogleMapViewmodel.kt b/app/src/main/java/com/example/bettinalogistics/ui/activity/gg_map/GoogleMapViewmodel.kt
--- a/app/src/main/java/com/example/bettinalogistics/ui/activity/gg_map/GoogleMapViewmodel.kt	(revision 543c71394d916d6931312efbffc17cf4f990eb1f)
+++ b/app/src/main/java/com/example/bettinalogistics/ui/activity/gg_map/GoogleMapViewmodel.kt	(date 1668770305897)
@@ -1,6 +1,7 @@
 package com.example.bettinalogistics.ui.activity.gg_map
 
 import android.content.ContentValues
+import android.content.Context
 import android.util.Log
 import androidx.lifecycle.MutableLiveData
 import androidx.lifecycle.viewModelScope
@@ -8,6 +9,9 @@
 import com.example.bettinalogistics.data.GoogleMapRepo
 import com.example.bettinalogistics.model.AddressData
 import com.google.android.gms.maps.model.LatLng
+import com.google.maps.DirectionsApi
+import com.google.maps.DirectionsApiRequest
+import com.google.maps.GeoApiContext
 import com.google.maps.android.SphericalUtil
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.launch
@@ -56,4 +60,13 @@
         }
         return null
     }
+    val requestApiLiveData = MutableLiveData<DirectionsApiRequest>()
+    fun requestGgApi(context: GeoApiContext) =  viewModelScope.launch(Dispatchers.IO){
+        val req = DirectionsApi.getDirections(
+            context,
+            "${latLonOriginAddress?.latitude ?: ""},${latLonOriginAddress?.longitude ?: ""}",
+            "${latLonDestinationAddress?.latitude ?: ""},${latLonDestinationAddress?.longitude ?: ""}"
+        )
+        requestApiLiveData.postValue(req)
+    }
 }
\ No newline at end of file
Index: app/src/main/java/com/example/bettinalogistics/ui/activity/gg_map/GoogleMapActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.bettinalogistics.ui.activity.gg_map\r\n\r\nimport android.Manifest\r\nimport android.annotation.SuppressLint\r\nimport android.content.Context\r\nimport android.content.Intent\r\nimport android.content.pm.PackageManager\r\nimport android.graphics.Bitmap\r\nimport android.graphics.Canvas\r\nimport android.graphics.Color\r\nimport android.location.Address\r\nimport android.location.Geocoder\r\nimport android.location.Location\r\nimport android.util.Log\r\nimport android.view.View\r\nimport android.widget.Toast\r\nimport androidx.core.app.ActivityCompat\r\nimport androidx.core.content.ContextCompat\r\nimport com.directions.route.*\r\nimport com.example.baseapp.BaseActivity\r\nimport com.example.baseapp.view.setSafeOnClickListener\r\nimport com.example.bettinalogistics.R\r\nimport com.example.bettinalogistics.databinding.ActivityGoogleMapBinding\r\nimport com.example.bettinalogistics.model.AddressData\r\nimport com.example.bettinalogistics.model.OrderAddress\r\nimport com.example.bettinalogistics.network.RetrofitApi\r\nimport com.example.bettinalogistics.ui.activity.add_new_order.AddAddressTransactionActivity\r\nimport com.example.bettinalogistics.utils.AppConstant\r\nimport com.example.bettinalogistics.utils.Utils\r\nimport com.google.android.gms.common.ConnectionResult\r\nimport com.google.android.gms.common.api.GoogleApiClient\r\nimport com.google.android.gms.location.FusedLocationProviderClient\r\nimport com.google.android.gms.location.LocationServices\r\nimport com.google.android.gms.maps.CameraUpdateFactory\r\nimport com.google.android.gms.maps.GoogleMap\r\nimport com.google.android.gms.maps.OnMapReadyCallback\r\nimport com.google.android.gms.maps.SupportMapFragment\r\nimport com.google.android.gms.maps.model.*\r\nimport com.google.android.material.snackbar.Snackbar\r\nimport com.google.maps.DirectionsApi\r\nimport com.google.maps.GeoApiContext\r\nimport kotlinx.coroutines.async\r\nimport kotlinx.coroutines.runBlocking\r\nimport org.koin.androidx.viewmodel.ext.android.viewModel\r\nimport java.io.IOException\r\n\r\n\r\nclass GoogleMapActivity : BaseActivity(), OnMapReadyCallback, GoogleMap.OnMarkerClickListener,\r\n    GoogleApiClient.OnConnectionFailedListener, RoutingListener {\r\n    private var mMap: GoogleMap? = null\r\n    private var mapFragment: SupportMapFragment? = null\r\n    private var apiInterface: RetrofitApi? = null\r\n    var setOnSearchMapDone: ((Boolean, Boolean) -> Unit)? = null\r\n    override val viewModel: GoogleMapViewmodel by viewModel()\r\n    private lateinit var lastLocation: Location\r\n    private lateinit var fusedLocationClient: FusedLocationProviderClient\r\n\r\n    var myLocation: Location? = null\r\n    var destinationLocation: Location? = null\r\n    protected var start: LatLng? = null\r\n    protected var end: LatLng? = null\r\n\r\n    var locationPermission = false\r\n\r\n    //polyline object\r\n    private var polylines: ArrayList<Polyline>? = null\r\n\r\n    companion object {\r\n        private const val LOCATION_REQUEST_CODE = 1\r\n    }\r\n\r\n    override val binding: ActivityGoogleMapBinding by lazy {\r\n        ActivityGoogleMapBinding.inflate(layoutInflater)\r\n    }\r\n\r\n    override fun initView() {\r\n        mapFragment =\r\n            supportFragmentManager.findFragmentById(R.id.mapLocation) as SupportMapFragment?\r\n        binding.edtOriginSearch.requestFocus()\r\n        mapFragment?.getMapAsync(this);\r\n    }\r\n\r\n    override fun initListener() {\r\n        binding.btnFindPath.setSafeOnClickListener {\r\n            drawMap()\r\n            /*\r\n            if (checkValidate()) {\r\n                val addressData = AddressData(\r\n                    originAddress = binding.edtOriginSearch.getValueText(),\r\n                    originAddressLat = viewModel.latLonOriginAddress?.latitude,\r\n                    originAddressLon = viewModel.latLonOriginAddress?.longitude,\r\n                    destinationAddress = binding.edtDestinationSearch.getValueText(),\r\n                    destinationLat = viewModel.latLonDestinationAddress?.latitude,\r\n                    destinationLon = viewModel.latLonDestinationAddress?.longitude\r\n                )\r\n                viewModel.calculateDistance(addressData)\r\n               //  drawMap()\r\n              //  Findroutes(viewModel.latLonOriginAddress,viewModel.latLonDestinationAddress);\r\n            }\r\n\r\n             */\r\n        }\r\n        binding.edtOriginSearch.setOnEdittextDone = { origin ->\r\n            if (origin.isEmpty()) {\r\n                binding.edtOriginSearch.requestFocus()\r\n                binding.edtOriginSearch.setVisibleMessageError(getString(R.string.invalid_field))\r\n            } else {\r\n                binding.edtOriginSearch.setGoneMessageError()\r\n                setUpOriginLatLon()\r\n            }\r\n        }\r\n        binding.edtOriginSearch.onFocusChange = {\r\n            if (!it) {\r\n                val origin = binding.edtOriginSearch.getValueText()\r\n                if (origin.isEmpty()) {\r\n                    binding.edtOriginSearch.requestFocus()\r\n                    binding.edtOriginSearch.setVisibleMessageError(getString(R.string.invalid_field))\r\n                } else {\r\n                    binding.edtOriginSearch.setGoneMessageError()\r\n                    setUpOriginLatLon()\r\n                }\r\n            }\r\n        }\r\n        binding.edtDestinationSearch.setOnEdittextDone = { destination ->\r\n            if (destination.isNotEmpty()) {\r\n                setUpDestinationLatLon()\r\n            } else {\r\n                binding.edtDestinationSearch.requestFocus()\r\n                binding.edtDestinationSearch.setVisibleMessageError(getString(R.string.invalid_field))\r\n            }\r\n        }\r\n        binding.edtDestinationSearch.onFocusChange = {\r\n            if (!it) {\r\n                val destination = binding.edtDestinationSearch.getValueText()\r\n                if (destination.isNotEmpty()) {\r\n                    binding.edtDestinationSearch.setGoneMessageError()\r\n                    setUpDestinationLatLon()\r\n                } else {\r\n                    binding.edtDestinationSearch.requestFocus()\r\n                    binding.edtDestinationSearch.setVisibleMessageError(getString(R.string.invalid_field))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun setUpOriginLatLon() {\r\n        val locationOrigin = binding.edtOriginSearch.getValueText()\r\n        var addressList: List<Address>? = null;\r\n        if (locationOrigin.isNotEmpty()) {\r\n            val geocoder = Geocoder(this@GoogleMapActivity);\r\n            try {\r\n                addressList = geocoder.getFromLocationName(locationOrigin, 1);\r\n            } catch (e: IOException) {\r\n                e.printStackTrace();\r\n            }\r\n            val address = addressList?.get(0);\r\n            val latLng = address?.let { LatLng(it.latitude, it.longitude) };\r\n            viewModel.latLonOriginAddress = latLng\r\n            latLng?.let { MarkerOptions().position(it).title(locationOrigin) }\r\n                ?.let { mMap?.addMarker(it) };\r\n\r\n            latLng?.let { CameraUpdateFactory.newLatLngZoom(it, 10F) }\r\n                ?.let { mMap?.animateCamera(it) };\r\n        }\r\n    }\r\n\r\n    private fun setUpDestinationLatLon() {\r\n        val locationDestination = binding.edtDestinationSearch.getValueText()\r\n        var addressList: List<Address>? = null;\r\n        if (locationDestination.isNotEmpty()) {\r\n            val geocoder = Geocoder(this@GoogleMapActivity);\r\n            try {\r\n                addressList = geocoder.getFromLocationName(locationDestination, 1);\r\n            } catch (e: IOException) {\r\n                e.printStackTrace();\r\n            }\r\n            val address = addressList?.get(0);\r\n            if(address == null){\r\n                confirm.setNotice(getString(R.string.str_choose_address_again))\r\n            }\r\n           else{\r\n                val latLng = address.let { LatLng(it.latitude, it.longitude) };\r\n                latLng.let { MarkerOptions().position(it).title(locationDestination) }\r\n                    .let { mMap?.addMarker(it) };\r\n\r\n                latLng.let { CameraUpdateFactory.newLatLngZoom(it, 10F) }\r\n                    .let { mMap?.animateCamera(it) };\r\n                viewModel.latLonDestinationAddress = latLng\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun checkValidate(): Boolean {\r\n        if (binding.edtOriginSearch.getValueText().isEmpty()) {\r\n            binding.edtOriginSearch.requestFocus()\r\n            binding.edtOriginSearch.setVisibleMessageError(getString(R.string.invalid_field))\r\n            return false\r\n        } else if (binding.edtDestinationSearch.getValueText().isEmpty()) {\r\n            binding.edtDestinationSearch.requestFocus()\r\n            binding.edtDestinationSearch.setVisibleMessageError(getString(R.string.invalid_field))\r\n            return false\r\n        }\r\n        return true\r\n    }\r\n\r\n    override fun observeData() {\r\n        viewModel.calculateDistanceLiveData.observe(this) {\r\n            if(it != null){\r\n                viewModel.distance = it\r\n                val addressData = AddressData(\r\n                    originAddress = binding.edtOriginSearch.getValueText(),\r\n                    originAddressLat = viewModel.latLonOriginAddress?.latitude,\r\n                    originAddressLon = viewModel.latLonOriginAddress?.longitude,\r\n                    destinationAddress = binding.edtDestinationSearch.getValueText(),\r\n                    destinationLat = viewModel.latLonDestinationAddress?.latitude,\r\n                    destinationLon = viewModel.latLonDestinationAddress?.longitude\r\n                )\r\n                val orderAddress = OrderAddress(addressData, it.toDouble())\r\n                val i = Intent()\r\n                i.putExtra(AddAddressTransactionActivity.NEW_ADDRESS_ORDER, Utils.g().getJsonFromObject(orderAddress))\r\n                setResult(RESULT_OK, i)\r\n                finish()\r\n            }\r\n        }\r\n    }\r\n\r\n    @SuppressLint(\"PotentialBehaviorOverride\")\r\n    override fun onMapReady(p0: GoogleMap) {\r\n        mMap = p0\r\n        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)\r\n        mMap?.uiSettings?.isZoomControlsEnabled = true\r\n        mMap?.setOnMarkerClickListener(this)\r\n        setUpMap()\r\n    }\r\n\r\n    private fun Findroutes(Start: LatLng?, End: LatLng?) {\r\n        if (Start == null || End == null) {\r\n            Toast.makeText(this, \"Unable to get location\", Toast.LENGTH_LONG).show()\r\n        } else {\r\n            val routing = Routing.Builder()\r\n                .travelMode(AbstractRouting.TravelMode.DRIVING)\r\n                .withListener(this)\r\n                .alternativeRoutes(true)\r\n                .waypoints(Start, End)\r\n                .key(getString(R.string.API_KEY)) //also define your api key here.\r\n                .build()\r\n            routing.execute()\r\n        }\r\n    }\r\n\r\n    override fun onRoutingFailure(e: RouteException) {\r\n        val parentLayout: View = findViewById(android.R.id.content)\r\n        val snackbar: Snackbar = Snackbar.make(parentLayout, e.toString(), Snackbar.LENGTH_LONG)\r\n        snackbar.show()\r\n//        Findroutes(start,end);\r\n    }\r\n\r\n    override fun onRoutingStart() {\r\n        Toast.makeText(this, \"Finding Route...\", Toast.LENGTH_LONG).show()\r\n    }\r\n\r\n    //If Route finding success..\r\n    override fun onRoutingSuccess(route: ArrayList<Route>, shortestRouteIndex: Int) {\r\n        val center = CameraUpdateFactory.newLatLng(start!!)\r\n        val zoom = CameraUpdateFactory.zoomTo(16f)\r\n        polylines?.clear()\r\n        val polyOptions = PolylineOptions()\r\n        var polylineStartLatLng: LatLng? = null\r\n        var polylineEndLatLng: LatLng? = null\r\n        polylines = ArrayList()\r\n        //add route(s) to the map using polyline\r\n        for (i in 0 until route.size) {\r\n            if (i == shortestRouteIndex) {\r\n                polyOptions.color(resources.getColor(R.color.blue_dark))\r\n                polyOptions.width(7f)\r\n                polyOptions.addAll(route[shortestRouteIndex].getPoints())\r\n                val polyline = mMap!!.addPolyline(polyOptions)\r\n                polylineStartLatLng = polyline.points[0]\r\n                val k: Int = polyline.points.size\r\n                polylineEndLatLng = polyline.points[k - 1]\r\n                polylines!!.add(polyline)\r\n            } else {\r\n            }\r\n        }\r\n\r\n        //Add Marker on route starting position\r\n        val startMarker = MarkerOptions()\r\n        startMarker.position(polylineStartLatLng!!)\r\n        startMarker.title(binding.edtOriginSearch.getValueText())\r\n        mMap!!.addMarker(startMarker)\r\n\r\n        //Add Marker on route ending position\r\n        val endMarker = MarkerOptions()\r\n        endMarker.position(polylineEndLatLng!!)\r\n        endMarker.title(binding.edtDestinationSearch.getValueText())\r\n        mMap!!.addMarker(endMarker)\r\n    }\r\n\r\n    override fun onRoutingCancelled() {\r\n        Findroutes(start, end)\r\n    }\r\n\r\n    override fun onConnectionFailed(p0: ConnectionResult) {\r\n        Findroutes(start, end)\r\n    }\r\n\r\n    private fun bitmapFromVector(context: Context, vectorResId: Int): BitmapDescriptor {\r\n        val vectorDrawable = ContextCompat.getDrawable(context, vectorResId)\r\n        vectorDrawable!!.setBounds(\r\n            0,\r\n            0,\r\n            vectorDrawable.intrinsicWidth,\r\n            vectorDrawable.intrinsicHeight\r\n        )\r\n        val bitmap = Bitmap.createBitmap(\r\n            vectorDrawable.intrinsicWidth,\r\n            vectorDrawable.intrinsicHeight,\r\n            Bitmap.Config.ARGB_8888\r\n        )\r\n        val canvas = Canvas(bitmap)\r\n        vectorDrawable.draw(canvas)\r\n        return BitmapDescriptorFactory.fromBitmap(bitmap)\r\n    }\r\n\r\n    private fun drawMap() {\r\n        viewModel.latLonOriginAddress?.let {\r\n            MarkerOptions().position(it).title(binding.edtOriginSearch.getValueText())\r\n        }\r\n            ?.let { mMap!!.addMarker(it) }\r\n        viewModel.latLonDestinationAddress?.let {\r\n            MarkerOptions().position(it).title(binding.edtDestinationSearch.getValueText())\r\n        }\r\n            ?.let { mMap!!.addMarker(it) }\r\n\r\n        val path: MutableList<LatLng> = ArrayList()\r\n\r\n        val context = GeoApiContext.Builder()\r\n            .apiKey(getString(R.string.API_KEY))\r\n            .build()\r\n        val req = DirectionsApi.getDirections(\r\n            context,\r\n            \"${viewModel.latLonOriginAddress?.latitude ?: \"\"},${viewModel.latLonOriginAddress?.longitude ?: \"\"}\",\r\n            \"${viewModel.latLonDestinationAddress?.latitude ?: \"\"},${viewModel.latLonDestinationAddress?.longitude ?: \"\"}\"\r\n        )\r\n        try {\r\n            runBlocking {\r\n                async {\r\n                    val res =   req.await()\r\n\r\n                if (res.routes != null && res.routes.isNotEmpty()) {\r\n                    val route = res.routes[0]\r\n                    if (route.legs != null) {\r\n                        for (i in route.legs.indices) {\r\n                            val leg = route.legs[i]\r\n                            if (leg.steps != null) {\r\n                                for (j in leg.steps.indices) {\r\n                                    val step = leg.steps[j]\r\n                                    if (step.steps != null && step.steps.size > 0) {\r\n                                    for (k in step.steps.indices) {\r\n                                        val step1 = step.steps[k]\r\n                                        val points1 = step1.polyline\r\n                                        if (points1 != null) {\r\n                                            //Decode polyline and add points to list of route coordinates\r\n                                            val coords1 = points1.decodePath()\r\n                                            for (coord1 in coords1) {\r\n                                                path.add(LatLng(coord1.lat, coord1.lng))\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    val points = step.polyline\r\n                                    if (points != null) {\r\n                                        val coords = points.decodePath()\r\n                                        for (coord in coords) {\r\n                                            path.add(LatLng(coord.lat, coord.lng))\r\n                                        }\r\n                                    }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (path.size > 0) {\r\n                    val opts = PolylineOptions().addAll(path).color(Color.BLUE).width(5f)\r\n                    mMap!!.addPolyline(opts)\r\n                }\r\n\r\n                mMap!!.uiSettings.isZoomControlsEnabled = true\r\n            }\r\n            }\r\n        } catch (ex: Exception) {\r\n            ex.localizedMessage?.let { Log.e(AppConstant.TAG, it) }\r\n        }\r\n\r\n    }\r\n\r\n/*\r\n    override fun onDirectionFinderSuccess(routes: List<Route>) {\r\n        progressDialog?.dismiss();\r\n\r\n        for (route in routes) {\r\n            route.startLocation?.let { CameraUpdateFactory.newLatLngZoom(it, 16F) }\r\n                ?.let { mMap?.moveCamera(it) };\r\n            Log.d(TAG, \"onDirectionFinderSuccess: duration = ${route.duration?.text}\")\r\n            Log.d(TAG, \"onDirectionFinderSuccess: distance = ${route.distance?.text}\")\r\n\r\n            route.startLocation?.let {\r\n                MarkerOptions()\r\n                    .icon(BitmapDescriptorFactory.fromResource(R.drawable.ic_location))\r\n                    .title(route.startAddress)\r\n                    .position(it)\r\n            }?.let {\r\n                mMap?.addMarker(\r\n                    it\r\n                )?.let { originMarkers.add(it) }\r\n            };\r\n            route.endLocation?.let {\r\n                MarkerOptions()\r\n                    .icon(BitmapDescriptorFactory.fromResource(R.drawable.ic_location))\r\n                    .title(route.endAddress)\r\n                    .position(it)\r\n            }?.let { mMap?.addMarker(it)?.let { destinationMarkers.add(it) } };\r\n\r\n            val polylineOptions = PolylineOptions().\r\n            geodesic(true).\r\n            color(Color.BLUE).\r\n            width(10F);\r\n\r\n            for (i in route.points?.indices!!)\r\n            polylineOptions.add(route.points!!.get(i));\r\n\r\n            mMap?.addPolyline(polylineOptions)?.let { polylinePaths.add(it) };\r\n        }\r\n\r\n\r\n    }\r\n\r\n */\r\n\r\n    private fun setUpMap() {\r\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)\r\n            != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(\r\n                this, Manifest.permission.ACCESS_COARSE_LOCATION\r\n            )\r\n            != PackageManager.PERMISSION_GRANTED\r\n        ) {\r\n            ActivityCompat.requestPermissions(\r\n                this, arrayOf(android.Manifest.permission.ACCESS_FINE_LOCATION),\r\n                LOCATION_REQUEST_CODE\r\n            )\r\n            return\r\n        }\r\n        mMap?.isMyLocationEnabled = true\r\n        fusedLocationClient.lastLocation.addOnSuccessListener(this) { location ->\r\n            if (location != null) {\r\n                lastLocation = location\r\n                val currentLatLong = LatLng(location.latitude, location.longitude)\r\n              //  placeMarkerOnMap(currentLatLong)\r\n               // mMap?.animateCamera(CameraUpdateFactory.newLatLngZoom(currentLatLong, 12f))\r\n            }\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n    private fun placeMarkerOnMap(currentLatLong: LatLng) {\r\n//        val markerOptions = MarkerOptions().position(currentLatLong)\r\n//        markerOptions.title(\"$currentLatLong\")\r\n//        mMap?.addMarker(markerOptions)\r\n    }\r\n\r\n    override fun onMarkerClick(p0: Marker) = false\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/bettinalogistics/ui/activity/gg_map/GoogleMapActivity.kt b/app/src/main/java/com/example/bettinalogistics/ui/activity/gg_map/GoogleMapActivity.kt
--- a/app/src/main/java/com/example/bettinalogistics/ui/activity/gg_map/GoogleMapActivity.kt	(revision 543c71394d916d6931312efbffc17cf4f990eb1f)
+++ b/app/src/main/java/com/example/bettinalogistics/ui/activity/gg_map/GoogleMapActivity.kt	(date 1668770770568)
@@ -337,16 +337,10 @@
         val context = GeoApiContext.Builder()
             .apiKey(getString(R.string.API_KEY))
             .build()
-        val req = DirectionsApi.getDirections(
-            context,
-            "${viewModel.latLonOriginAddress?.latitude ?: ""},${viewModel.latLonOriginAddress?.longitude ?: ""}",
-            "${viewModel.latLonDestinationAddress?.latitude ?: ""},${viewModel.latLonDestinationAddress?.longitude ?: ""}"
-        )
-        try {
-            runBlocking {
-                async {
-                    val res =   req.await()
-
+        viewModel.requestGgApi(context)
+        viewModel.requestApiLiveData.observe(this) {
+            try {
+                val res =  it.await()
                 if (res.routes != null && res.routes.isNotEmpty()) {
                     val route = res.routes[0]
                     if (route.legs != null) {
@@ -356,25 +350,25 @@
                                 for (j in leg.steps.indices) {
                                     val step = leg.steps[j]
                                     if (step.steps != null && step.steps.size > 0) {
-                                    for (k in step.steps.indices) {
-                                        val step1 = step.steps[k]
-                                        val points1 = step1.polyline
-                                        if (points1 != null) {
-                                            //Decode polyline and add points to list of route coordinates
-                                            val coords1 = points1.decodePath()
-                                            for (coord1 in coords1) {
-                                                path.add(LatLng(coord1.lat, coord1.lng))
-                                            }
-                                        }
-                                    }
-                                } else {
-                                    val points = step.polyline
-                                    if (points != null) {
-                                        val coords = points.decodePath()
-                                        for (coord in coords) {
-                                            path.add(LatLng(coord.lat, coord.lng))
-                                        }
-                                    }
+                                        for (k in step.steps.indices) {
+                                            val step1 = step.steps[k]
+                                            val points1 = step1.polyline
+                                            if (points1 != null) {
+                                                //Decode polyline and add points to list of route coordinates
+                                                val coords1 = points1.decodePath()
+                                                for (coord1 in coords1) {
+                                                    path.add(LatLng(coord1.lat, coord1.lng))
+                                                }
+                                            }
+                                        }
+                                    } else {
+                                        val points = step.polyline
+                                        if (points != null) {
+                                            val coords = points.decodePath()
+                                            for (coord in coords) {
+                                                path.add(LatLng(coord.lat, coord.lng))
+                                            }
+                                        }
                                     }
                                 }
                             }
@@ -387,10 +381,9 @@
                 }
 
                 mMap!!.uiSettings.isZoomControlsEnabled = true
-            }
-            }
-        } catch (ex: Exception) {
-            ex.localizedMessage?.let { Log.e(AppConstant.TAG, it) }
+            } catch (ex: Exception) {
+                ex.localizedMessage?.let { Log.e(AppConstant.TAG, it) }
+            }
         }
 
     }
